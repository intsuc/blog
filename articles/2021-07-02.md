# Compiling First-Order Language to Datapack

## Prerequisites

- Basics of [*type theory*](https://ncatlab.org/nlab/show/type+theory) as in [*Types and Programming Languages*](https://dl.acm.org/doi/10.5555/509043) and [*Practical Foundations for Programming Languages*](https://dl.acm.org/doi/10.5555/3002812)
- Basics of [*datapacks*](https://minecraft.fandom.com/wiki/Data_Pack), especially about [*NBT*](https://minecraft.fandom.com/wiki/NBT_format) manipulation

## Introduction

There are a lot of programming languages in the world, but very few of them have datapacks as a compiler target.
So, let us define such a language and compile it to a datapack.

## Language ğ“—

First, let us define ğ“—, a high-level first-order language.

### First-Order Restriction

For brevity, ğ“— is restricted to *first-order*.
The definition of "first-order" follows that of [[1](#1)]:

> ... we will say that a programming language is *higher-order* if procedures or labels can occur as data, i.e., if these entities can be used as arguments to procedures, as results of functions, or as values of assignable variables. A language that is not higher-order will be called *first-order*.

### Syntax

The syntax of ğ“— is defined as follows:

```agda
        Variable  x, y

 Integer literal  n

 Function symbol  f

         Program  p     ::=  e                      (entry point)
                          |  f(x : A) : A = e; p    (function definition)

            Type  A, B  ::=  Int                    (integer type)

      Expression  e     ::=  x                      (variable)
                          |  n                      (integer literal)
                          |  f(e)                   (function application)
                          |  let x = e; e           (let binding)

           Value  v     ::=  x                      (variable)
                          |  n                      (integer literal)

       Signature  Î£     ::=  âˆ…                      (empty)
                          |  Î£, f(x : A) : A = e    (extension)

         Context  Î“     ::=  âˆ…                      (empty)
                          |  Î“, x : A               (extension)

Variable context  Î”     ::=  âˆ…                      (empty)
                          |  Î”, x                   (extension)
```

- `x` and `y` are metavariables ranging over variables.
- `n` is a metavariable ranging over literals of 32-bit signed integers.
- `f` is a metavariable ranging over function symbols.
- `p` is either an entry point or a function definition. The parameter and return types of the function are explicit. The arity of the function is always 1.
- `A` and `B` are always integer types.
- `e` is either a variable, an integer literal, a let binding, or a function application. Due to the first-order restriction, the function `f` must be fully-applied.
- `v` is either a variable or an integer literal. A value is a fully-evaluated expression.
- `Î£` is either an empty signature or a function extension. A signature is used to store global functions.
- `Î“` is either an empty context or a variable typing extension. A context is used to store local variables.
- `Î”` is either an empty variable context or a variable extension. A variable context is a type-erased context.

### Typing Rules

The unidirectional typing rules of ğ“— is defined as follows:

```agda
Î£ âŠ¢ p    Under signature Î£, program p is well-formed.


Î£; âˆ… âŠ¢ e : A
------------ (entry)
Î£ âŠ¢ e


Î£, f(x : A) : B = e; x : A âŠ¢ e : B    Î£, f(x : A) : B = e âŠ¢ p
-------------------------------------------------------------- (def)
Î£ âŠ¢ f(x : A) : B = e; p
```

- `(entry)`: the entry point is well-formed if its expression is well-typed under the signature and the empty context.
- `(def)`: the function definition is well-formed if its body expression is well-typed under the signature extended itself and the context of its parameter only.

```agda
Î£; Î“ âŠ¢ e : A    Under signature Î£ and context Î“, expression e has type A.


x : A âˆˆ Î“
------------ (var)
Î£; Î“ âŠ¢ x : A


-------------- (int)
Î£; Î“ âŠ¢ n : Int


f(x : A) : B = _ âˆˆ Î£    Î£; Î“ âŠ¢ eâ‚ : A
------------------------------------- (app)
Î£; Î“ âŠ¢ f(eâ‚) : B


Î£; Î“ âŠ¢ eâ‚ : A    Î£; Î“, x : A âŠ¢ eâ‚‚ : B
------------------------------------- (let)
Î£; Î“ âŠ¢ let x = eâ‚; eâ‚‚ : B
```

Let us *bidirectionalize* [[2](#2)] the rules above.
The bidirectional typing rules of ğ“— is defined as follows:

```agda
Î£ âŠ¢ p    Under signature Î£, program p is well-formed.


Î£; âˆ… âŠ¢ e â‡’ A
------------ (entry)
Î£ âŠ¢ e


Î£, f(x : A) : B = e ; x : A âŠ¢ e â‡ B    Î£, f(x : A) : B = e âŠ¢ p
-------------------------------------------------------------- (def)
Î£ âŠ¢ f(x : A) : B = e; p
```

- `(entry)`: the expression of the entry point synthesizes the type `A` because we do not know the type.
- `(def)`: the body expression of the function checks against the type `B` because we know the type from the signature `Î£`.

```agda
Î£; Î“ âŠ¢ e â‡ A    Under signature Î£ and context Î“, expression e checks against type A.
Î£; Î“ âŠ¢ e â‡’ A    Under signature Î£ and context Î“, expression e synthesizes type A.


x : A âˆˆ Î“
------------ (varâ‡’)
Î£; Î“ âŠ¢ x â‡’ A


-------------- (intâ‡’)
Î£; Î“ âŠ¢ n â‡’ Int


f(x : A) : B = _ âˆˆ Î£    Î£; Î“ âŠ¢ eâ‚ â‡ A
------------------------------------- (appâ‡’)
Î£; Î“ âŠ¢ f(eâ‚) â‡’ B


Î£; Î“ âŠ¢ eâ‚ â‡’ A    Î£; Î“, x : A âŠ¢ eâ‚‚ â‡ B
------------------------------------- (letâ‡)
Î£; Î“ âŠ¢ let x = eâ‚; eâ‚‚ â‡ B


Î£; Î“ âŠ¢ eâ‚ â‡’ A    Î£; Î“, x : A âŠ¢ eâ‚‚ â‡’ B
------------------------------------- (letâ‡’)
Î£; Î“ âŠ¢ let x = eâ‚; eâ‚‚ â‡’ B


Î£; Î“ âŠ¢ e â‡’ A    A = B
--------------------- (subâ‡’)
Î£; Î“ âŠ¢ e â‡ B
```

The rules above are all mode-correct, and thus directly implementable.

### Operational Semantics

The operational semantics of ğ“— is defined as follows:

```agda
Î£ âŠ¢ e âŸ¶ v    Under signature Î£, expression e evaluates to value v.


---------- (var)
Î£ âŠ¢ x âŸ¶ x


---------- (int)
Î£ âŠ¢ n âŸ¶ n


Î£ âŠ¢ eâ‚ âŸ¶ vâ‚    f(x : _) : B = eâ‚‚ âˆˆ Î£    Î£ âŠ¢ eâ‚‚[vâ‚/x] âŸ¶ vâ‚‚
----------------------------------------------------------- (app)
Î£ âŠ¢ f(eâ‚) âŸ¶ vâ‚‚


Î£ âŠ¢ eâ‚ âŸ¶ vâ‚    Î£ âŠ¢ eâ‚‚[vâ‚/x] âŸ¶ vâ‚‚
---------------------------------- (let)
Î£ âŠ¢ let x = eâ‚; eâ‚‚ âŸ¶ vâ‚‚
```

where the substitution is defined as follows:

```agda
               _[_/_] : Expression â†’ Value â†’ Variable â†’ Expression
               y[v/x] = v                           where  x = y
               y[v/x] = y                           where  x â‰  y
               n[v/x] = n
            f(e)[v/x] = f(e[v/x])
(let y = eâ‚; eâ‚‚)[v/x] = (let y = eâ‚[v/x]; eâ‚‚)       where  x = y
(let y = eâ‚; eâ‚‚)[v/x] = (let y = eâ‚[v/x]; eâ‚‚[v/x])  where  x â‰  y
```

The operational semantics above uses substitution, which is recursive operation on syntax, to model function application.
This is not appropriate for datapacks.
So, we need to define a lower-level language than ğ“— and compile ğ“— to it first.

## Language ğ“›

Next, let us define ğ“›, a low-level first-order language.

### Syntax

The syntax of ğ“› is defined as follows:

```agda
 Variable index  i

Integer literal  n

Function symbol  f

        Program  p  ::=  s           (entry point)
                      |  f = s; p    (function definition)

      Statement  s  ::=  âˆ…           (empty)
                      |  e; s        (sequence)

     Expression  e  ::=  i           (variable index)
                      |  n           (integer literal)
                      |  f           (function call)
                      |  return      (return marker)

          Value  v  ::=  n           (integer literal)

      Signature  Î£  ::=  âˆ…           (empty)
                      |  Î£, f = s    (extension)

          Stack  S  ::=  âˆ…           (empty)
                      |  S, v        (value extension)
```

- `i` is a metavariable ranging over variable indices. *De Bruijn index* [[3](#3)] is used for its representation.
- `n` is a metavariable ranging over literals of 32-bit signed integers.
- `f` is a metavariable ranging over function symbols.
- `p` is either an entry point or a function definition.
- `e` is either a variable index, an integer literal, a function call, or a return marker.
- `v` is always an integer literal.
- `Î£` is either an empty signature or a function extension.
- `S` is either an empty stack or a value extension. A stack is used to store local values.

### Compilation of ğ“— to ğ“›

Let us compile ğ“— to ğ“›. The compilation is defined as follows:

```agda
_âŸ¦_âŸ§ : Variable context â†’ ğ“—-Expression â†’ ğ“›-Statement
Î”âŸ¦xâŸ§              = Î”[x];
Î”âŸ¦nâŸ§              = n;
Î”âŸ¦f(e)âŸ§           = Î”âŸ¦eâŸ§; f; return;
Î”âŸ¦let x = eâ‚; eâ‚‚âŸ§ = Î”âŸ¦eâ‚âŸ§; (Î”, x)âŸ¦eâ‚‚âŸ§; return;
```

where the partial-function to calculate a variable index is defined as follows:

```agda
     _[_] : Variable context â†’ Variable â†’ Variable index
     âˆ…[x] = âŠ¥
(Î”, y)[x] = 0         where  x = y
(Î”, y)[x] = Î”[x] + 1  where  x â‰  y
```

The compilation is done recursively on ğ“—-Expressions.
In the cases of `f(e)` and `let x = eâ‚; eâ‚‚`, `return` is appended to the result statement.
These `return` markers are used to indicate where the value corresponding to the bound variable will be deallocated.

### Stack Semantics

To bring it closer to the execution in a real datapack, let us define the operational semantics with a stack.
The stack semantics of ğ“› is defined as follows:

```agda
âŸ¨S         |      i; sâŸ© âŸ¶ âŸ¨S, S[i] |     sâŸ©                       (var)
âŸ¨S         |      n; sâŸ© âŸ¶ âŸ¨S, n    |     sâŸ©                       (int)
âŸ¨S         |      f; sâŸ© âŸ¶ âŸ¨S       | sâ‚; sâŸ©  where  f = sâ‚ âˆˆ Î£    (fun)
âŸ¨S, vâ‚‚, vâ‚ | return; sâŸ© âŸ¶ âŸ¨S, vâ‚   |     sâŸ©                       (ret)
```

where the partial-function to lookup the value at a specified variable index is defined as follows:

```agda
     _[_] : Stack â†’ Variable index â†’ Value
     âˆ…[i] = âŠ¥
(S, v)[0] = v
(S, v)[i] = S[i - 1]
```

The stack semantics is represented by the state transitions of pairs of `Stack` and `Statement`.
The global signature `Î£` contains all the definitions in the program.

- `(var)`: the `i`-th value in the stack `S` is looked up and pushed to `S`.
- `(int)`: the integer literal `n` is pushed to the stack `S`.
- `(fun)`: the body statement `sâ‚` of the function `f` is appended to the statement `s`.
- `(ret)`: the second value `vâ‚‚` is removed from the stack `S`.

Now we know how ğ“› is executed with a stack.

## Compilation of ğ“› to Datapack

Finally, let us compile ğ“› to a datapack.
The compilation is straightforward and defined as follows:

```agda
âŸ¦_âŸ§ : Program â†’ Functions
âŸ¦sâŸ§        = main â†¦ "data modify storage _ stack set value []", âŸ¦sâŸ§
âŸ¦f = s; pâŸ§ = f â†¦ âŸ¦sâŸ§, âŸ¦pâŸ§
```

- `Functions` is a map from function symbols to `Commands`. Each entry `f â†¦ cs` represents a single mcfunction with resource location `f` and commands `cs`.
- `main` is a special function symbol for the entry point. `/data modify` command to initialize the stack is prepended to its commands.

```agda
âŸ¦_âŸ§ : Statement â†’ Commands
âŸ¦âˆ…âŸ§    = âˆ…
âŸ¦e; sâŸ§ = âŸ¦eâŸ§, âŸ¦sâŸ§
```

- `Commands` is a list of `Command`.

```agda
âŸ¦_âŸ§ : Expression â†’ Command
âŸ¦iâŸ§      = "data modify storage _ S append from storage _ S[${-(i + 1)}]"
âŸ¦nâŸ§      = "data modify storage _ S append value ${n}"
âŸ¦fâŸ§      = "function ${f}"
âŸ¦returnâŸ§ = "data remove storage _ S[-2]"
```

- `Command` is a command.
- The variable index `i` is compiled to `/data modify` command. The index is converted to match that of Minecraft.
- The integer literal `n` is compiled to `/data modify` command to push it.
- The function call `f` is compiled to `/function` command to call it.
- The return marker `return` is compiled to `/data remove` to deallocate an out-of-scope value.

To execute the compiled program, execute `/function main`.

## Conclusion

We found that the first-order language ğ“— can be compiled to a datapack.
Datapacks are expressive enough to be a compiler target for such a language.

Since we did not add any arithmetic operations or conditional branching to the language, we cannot write any non-trivial programs.
However, these could easily be added to the language.

We intentionally restricted the language to first-order.
This choice greatly simplifies the language design.
Although it is possible to compile a higher-order language to a datapack with transformations such as *defunctionalization* [[1](#1)], naÃ¯ve implementation will result in poor performance.
Designing practical higher-order programming languages for Minecraft is non-trivial.

## References

1. <a id="user-content-1"></a>[John C. Reynolds. 1972. **Definitional interpreters for higher-order programming languages**. In <i>Proceedings of the ACM annual conference - Volume 2</i> (<i>ACM '72</i>). Association for Computing Machinery, New York, NY, USA, 717â€“740.](https://doi.org/10.1145/800194.805852)
2. <a id="user-content-2"></a>[Jana Dunfield and Neel Krishnaswami. 2020. **Bidirectional Typing**.](https://arxiv.org/abs/1908.05839)
3. <a id="user-content-3"></a>[N.G de Bruijn. 1972. **Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem**.](https://doi.org/10.1016/1385-7258(72)90034-0)
